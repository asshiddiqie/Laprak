# <h1 align="center">Laporan Praktikum Modul 13 <br> MULTI LINKED LIST </h1>
<p align="center">ASSHIDDIQIE SYABANA PUTRA - 103112400129 </p>

## Dasar Teori

Multi List merupakan sekumpulan list yang berbeda yang memiliki suatu keterhubungan satu sama
lain. Tiap elemen dalam multi link list dapat membentuk listsendiri.Biasanya ada yang bersifat sebagai
list induk dan list anak.

## Guided

### multi linklist
```go
#include <iostream>
#include <string>
using namespace std;

struct ChildNode
{
    string info;
    ChildNode *next;
};

struct ParentNode
{
    string info;
    ChildNode *childHead;
    ParentNode *next;
};

ParentNode *createParent(string info)
{
    ParentNode *newNode = new ParentNode;
    newNode->info = info;
    newNode->childHead = NULL;
    newNode->next = NULL;
    return newNode;
}

ChildNode *createChild(string info)
{
    ChildNode *newNode = new ChildNode;
    newNode->info = info;
    newNode->next = NULL;
    return newNode;
}

void insertParent(ParentNode *&head, string info)
{
    ParentNode *newNode = createParent(info);
    if (head == NULL)
    {
        head = newNode;
    }
    else
    {
        ParentNode *temp = head;
        while (temp->next != NULL)
        {
            temp = temp->next;
        }
        temp->next = newNode;
    }
}

void insertChild(ParentNode *head, string parentInfo, string childInfo)
{
    ParentNode *p = head;
    while (p != NULL && p->info != parentInfo)
    {
        p = p->next;
    }

    if (p != NULL)
    {
        ChildNode *newChild = createChild(childInfo);
        if (p->childHead == NULL)
        {
            p->childHead = newChild;
        }
        else 
        {
            ChildNode *c = p->childHead;
            while (c->next != NULL)
            {
                c = c->next;
            }
            c->next = newChild;
        }
    }
}

void printAll(ParentNode *head)
{
    ParentNode *p = head;
    while (p != NULL)
    {
        cout << p->info;
        ChildNode *c = p->childHead;
        if (c != NULL)
        {
            while (c != NULL)
            {
                cout << " -> " << c->info;
                c = c->next;
            }
        }
        cout << endl;
        p = p->next;
    }
}

int main()
{
    ParentNode *list = NULL;

    insertParent(list, "Parent Node 1");
    insertParent(list, "Parent Node 2");

    insertChild(list, "Parent Node 1", "Child Node A");
    insertChild(list, "Parent Node 1", "Child Node B");
    insertChild(list, "Parent Node 2", "Child Node C");

    printAll(list);

    return 0;
}
```

## Unguided

### Soal 1

Perhatikan program 46 multilist.h, buat multilist.cpp untuk implementasi semua fungsi pada
multilist.h. Buat main.cpp untuk pemanggilan fungsi-fungsi tersebut.

### file multilist.h
```cpp
#ifndef MULTILIST_H_INCLUDED
#define MULTILIST_H_INCLUDED

#define Nil NULL

typedef int infotypeanak;
typedef int infotypeinduk;
typedef struct elemen_list_induk *address;
typedef struct elemen_list_anak *address_anak;

struct elemen_list_anak{
    infotypeanak info;
    address_anak next;
    address_anak prev;
};

struct listanak {
    address_anak first;
    address_anak last;
};

struct elemen_list_induk{
    infotypeinduk info;
    listanak lanak;
    address next;
    address prev;
};

struct listinduk {
    address first;
    address last;
};

typedef int boolean;
#define true 1
#define false 0

/********* pengecekan apakah list kosong ***********/
boolean ListEmpty(listinduk L);
boolean ListEmptyAnak(listanak L);

/********* pembuatan list kosong *********/
void CreateList(listinduk &L);
void CreateListAnak(listanak &L);

/********* manajemen memori *********/
address alokasi(infotypeinduk P);
address_anak alokasiAnak(infotypeanak P);
void dealokasi(address P);
void dealokasiAnak(address_anak P);

/********* pencarian sebuah elemen list *********/
address findElm(listinduk L, infotypeinduk X);
address_anak findElm(listanak Lanak, infotypeanak X);
boolean fFindElm(listinduk L, address P);
boolean fFindElmanak(listanak Lanak, address_anak P);
address findBefore(listinduk L, address P);
address_anak findBeforeAnak(listanak Lanak, infotypeinduk X, address_anak P);

/********* penambahan elemen **********/
void insertFirst(listinduk &L, address P);
void insertAfter(listinduk &L, address P, address Prec);
void insertLast(listinduk &L, address P);
void insertFirstAnak(listanak &L, address_anak P);
void insertAfterAnak(listanak &L, address_anak P, address_anak Prec);
void insertLastAnak(listanak &L, address_anak P);

/********* penghapusan sebuah elemen *********/
void delFirst(listinduk &L, address &P);
void delLast(listinduk &L, address &P);
void delAfter(listinduk &L, address &P, address Prec);
void delP(listinduk &L, infotypeinduk X);
void delFirstAnak(listanak &L, address_anak &P);
void delLastAnak(listanak &L, address_anak &P);
void delAfterAnak(listanak &L, address_anak &P, address_anak Prec);
void delPAnak(listanak &L, infotypeanak X);

/********** proses semua elemen list *********/
void printInfo(listinduk L);
int nbList(listinduk L);
void printInfoAnak(listanak Lanak);
int nbListAnak(listanak Lanak);

/********** proses terhadap list **********/
void delAll(listinduk &L);

#endif
```
### file multilist.cpp
```cpp
#include <iostream>
#include "multilist.h"
using namespace std;

// ========== PENGE CEKAN APAKAH LIST KOSONG ==========
boolean ListEmpty(listinduk L) {
    return (L.first == Nil);
}

boolean ListEmptyAnak(listanak L) {
    return (L.first == Nil);
}

// ========== PEMBUATAN LIST KOSONG ==========
void CreateList(listinduk &L) {
    L.first = Nil;
    L.last = Nil;
}

void CreateListAnak(listanak &L) {
    L.first = Nil;
    L.last = Nil;
}

// ========== MANAJEMEN MEMORI ==========
address alokasi(infotypeinduk P) {
    address newNode = new elemen_list_induk;
    if (newNode != Nil) {
        newNode->info = P;
        newNode->next = Nil;
        newNode->prev = Nil;
        CreateListAnak(newNode->lanak);
    }
    return newNode;
}

address_anak alokasiAnak(infotypeanak P) {
    address_anak newNode = new elemen_list_anak;
    if (newNode != Nil) {
        newNode->info = P;
        newNode->next = Nil;
        newNode->prev = Nil;
    }
    return newNode;
}

void dealokasi(address P) {
    if (P != Nil) {
        delete P;
    }
}

void dealokasiAnak(address_anak P) {
    if (P != Nil) {
        delete P;
    }
}

// ========== PENCARIAN SEBUAH ELEMEN LIST ==========
address findElm(listinduk L, infotypeinduk X) {
    address current = L.first;
    while (current != Nil) {
        if (current->info == X) {
            return current;
        }
        current = current->next;
    }
    return Nil;
}

address_anak findElm(listanak Lanak, infotypeanak X) {
    address_anak current = Lanak.first;
    while (current != Nil) {
        if (current->info == X) {
            return current;
        }
        current = current->next;
    }
    return Nil;
}

boolean fFindElm(listinduk L, address P) {
    address current = L.first;
    while (current != Nil) {
        if (current == P) {
            return true;
        }
        current = current->next;
    }
    return false;
}

boolean fFindElmanak(listanak Lanak, address_anak P) {
    address_anak current = Lanak.first;
    while (current != Nil) {
        if (current == P) {
            return true;
        }
        current = current->next;
    }
    return false;
}

address findBefore(listinduk L, address P) {
    if (P == L.first) {
        return Nil;
    }
    
    address current = L.first;
    while (current != Nil && current->next != P) {
        current = current->next;
    }
    return current;
}

address_anak findBeforeAnak(listanak Lanak, infotypeinduk X, address_anak P) {
    if (P == Lanak.first) {
        return Nil;
    }
    
    address_anak current = Lanak.first;
    while (current != Nil && current->next != P) {
        current = current->next;
    }
    return current;
}

// ========== PENAMBAHAN ELEMEN INDUK ==========
void insertFirst(listinduk &L, address P) {
    if (P != Nil) {
        if (ListEmpty(L)) {
            L.first = P;
            L.last = P;
        } else {
            P->next = L.first;
            L.first->prev = P;
            L.first = P;
        }
    }
}

void insertAfter(listinduk &L, address P, address Prec) {
    if (P != Nil && Prec != Nil) {
        if (Prec == L.last) {
            insertLast(L, P);
        } else {
            P->next = Prec->next;
            P->prev = Prec;
            Prec->next->prev = P;
            Prec->next = P;
        }
    }
}

void insertLast(listinduk &L, address P) {
    if (P != Nil) {
        if (ListEmpty(L)) {
            L.first = P;
            L.last = P;
        } else {
            P->prev = L.last;
            L.last->next = P;
            L.last = P;
        }
    }
}

// ========== PENAMBAHAN ELEMEN ANAK ==========
void insertFirstAnak(listanak &L, address_anak P) {
    if (P != Nil) {
        if (ListEmptyAnak(L)) {
            L.first = P;
            L.last = P;
        } else {
            P->next = L.first;
            L.first->prev = P;
            L.first = P;
        }
    }
}

void insertAfterAnak(listanak &L, address_anak P, address_anak Prec) {
    if (P != Nil && Prec != Nil) {
        if (Prec == L.last) {
            insertLastAnak(L, P);
        } else {
            P->next = Prec->next;
            P->prev = Prec;
            Prec->next->prev = P;
            Prec->next = P;
        }
    }
}

void insertLastAnak(listanak &L, address_anak P) {
    if (P != Nil) {
        if (ListEmptyAnak(L)) {
            L.first = P;
            L.last = P;
        } else {
            P->prev = L.last;
            L.last->next = P;
            L.last = P;
        }
    }
}

// ========== PENGHAPUSAN ELEMEN INDUK ==========
void delFirst(listinduk &L, address &P) {
    if (!ListEmpty(L)) {
        P = L.first;
        if (L.first == L.last) {
            L.first = Nil;
            L.last = Nil;
        } else {
            L.first = L.first->next;
            L.first->prev = Nil;
        }
        P->next = Nil;
        P->prev = Nil;
    }
}

void delLast(listinduk &L, address &P) {
    if (!ListEmpty(L)) {
        P = L.last;
        if (L.first == L.last) {
            L.first = Nil;
            L.last = Nil;
        } else {
            L.last = L.last->prev;
            L.last->next = Nil;
        }
        P->next = Nil;
        P->prev = Nil;
    }
}

void delAfter(listinduk &L, address &P, address Prec) {
    if (Prec != Nil && Prec->next != Nil) {
        P = Prec->next;
        if (P->next != Nil) {
            P->next->prev = Prec;
        } else {
            L.last = Prec;
        }
        Prec->next = P->next;
        P->next = Nil;
        P->prev = Nil;
    }
}

void delP(listinduk &L, infotypeinduk X) {
    address P = findElm(L, X);
    if (P != Nil) {
        // Hapus semua anak terlebih dahulu
        address_anak anakCurrent = P->lanak.first;
        while (anakCurrent != Nil) {
            address_anak temp = anakCurrent;
            anakCurrent = anakCurrent->next;
            dealokasiAnak(temp);
        }
        
        // Hapus induk dari list
        if (P == L.first) {
            L.first = P->next;
            if (L.first != Nil) {
                L.first->prev = Nil;
            }
        } else if (P == L.last) {
            L.last = P->prev;
            if (L.last != Nil) {
                L.last->next = Nil;
            }
        } else {
            P->prev->next = P->next;
            P->next->prev = P->prev;
        }
        P->next = Nil;
        P->prev = Nil;
        dealokasi(P);
    }
}

// ========== PENGHAPUSAN ELEMEN ANAK ==========
void delFirstAnak(listanak &L, address_anak &P) {
    if (!ListEmptyAnak(L)) {
        P = L.first;
        if (L.first == L.last) {
            L.first = Nil;
            L.last = Nil;
        } else {
            L.first = L.first->next;
            L.first->prev = Nil;
        }
        P->next = Nil;
        P->prev = Nil;
    }
}

void delLastAnak(listanak &L, address_anak &P) {
    if (!ListEmptyAnak(L)) {
        P = L.last;
        if (L.first == L.last) {
            L.first = Nil;
            L.last = Nil;
        } else {
            L.last = L.last->prev;
            L.last->next = Nil;
        }
        P->next = Nil;
        P->prev = Nil;
    }
}

void delAfterAnak(listanak &L, address_anak &P, address_anak Prec) {
    if (Prec != Nil && Prec->next != Nil) {
        P = Prec->next;
        if (P->next != Nil) {
            P->next->prev = Prec;
        } else {
            L.last = Prec;
        }
        Prec->next = P->next;
        P->next = Nil;
        P->prev = Nil;
    }
}

void delPAnak(listanak &L, infotypeanak X) {
    address_anak P = findElm(L, X);
    if (P != Nil) {
        if (P == L.first) {
            L.first = P->next;
            if (L.first != Nil) {
                L.first->prev = Nil;
            }
        } else if (P == L.last) {
            L.last = P->prev;
            if (L.last != Nil) {
                L.last->next = Nil;
            }
        } else {
            P->prev->next = P->next;
            P->next->prev = P->prev;
        }
        P->next = Nil;
        P->prev = Nil;
        dealokasiAnak(P);
    }
}

// ========== PROSES SEMUA ELEMEN LIST ==========
void printInfo(listinduk L) {
    address current = L.first;
    cout << "List Induk: ";
    while (current != Nil) {
        cout << current->info << " ";
        current = current->next;
    }
    cout << endl;
}

int nbList(listinduk L) {
    int count = 0;
    address current = L.first;
    while (current != Nil) {
        count++;
        current = current->next;
    }
    return count;
}

void printInfoAnak(listanak Lanak) {
    address_anak current = Lanak.first;
    cout << "List Anak: ";
    while (current != Nil) {
        cout << current->info << " ";
        current = current->next;
    }
    cout << endl;
}

int nbListAnak(listanak Lanak) {
    int count = 0;
    address_anak current = Lanak.first;
    while (current != Nil) {
        count++;
        current = current->next;
    }
    return count;
}

// ========== PROSES TERHADAP LIST ==========
void delAll(listinduk &L) {
    address current = L.first;
    while (current != Nil) {
        address temp = current;
        current = current->next;
        
        // Hapus semua anak
        address_anak anakCurrent = temp->lanak.first;
        while (anakCurrent != Nil) {
            address_anak anakTemp = anakCurrent;
            anakCurrent = anakCurrent->next;
            dealokasiAnak(anakTemp);
        }
        
        dealokasi(temp);
    }
    L.first = Nil;
    L.last = Nil;
}
```
### file main.cpp
```cpp
#include <iostream>
#include "multilist.h"
using namespace std;

void displayMultiList(listinduk L) {
    cout << "\n=== MULTI LINKED LIST DATA ===" << endl;
    cout << "==============================" << endl;
    
    if (ListEmpty(L)) {
        cout << "List kosong!" << endl;
        return;
    }
    
    int counter = 1;
    address induk = L.first;
    
    while (induk != Nil) {
        cout << counter << ". INDUK: " << induk->info << endl;
        cout << "   Jumlah Anak: " << nbListAnak(induk->lanak) << endl;
        
        if (!ListEmptyAnak(induk->lanak)) {
            cout << "   Daftar Anak: ";
            address_anak anak = induk->lanak.first;
            while (anak != Nil) {
                cout << anak->info;
                if (anak->next != Nil) cout << " -> ";
                anak = anak->next;
            }
            cout << endl;
        } else {
            cout << "   (Tidak memiliki anak)" << endl;
        }
        
        counter++;
        induk = induk->next;
    }
    
    cout << "\nTotal Induk: " << nbList(L) << endl;
    cout << "==============================\n" << endl;
}

int main() {
    cout << "=== PROGRAM MULTI LINKED LIST ===" << endl;
    cout << "=== (Implementasi dari multilist.h) ===\n" << endl;
    
    // ========== 1. Buat list kosong ==========
    listinduk L_pegawai;
    CreateList(L_pegawai);
    cout << "1. List kosong dibuat" << endl;
    cout << "   List kosong? " << (ListEmpty(L_pegawai) ? "Ya" : "Tidak") << endl;
    
    // ========== 2. Alokasi dan insert induk ==========
    cout << "\n2. Alokasi dan insert induk (pegawai):" << endl;
    address peg1 = alokasi(101); // Pegawai dengan ID 101
    address peg2 = alokasi(102); // Pegawai dengan ID 102
    address peg3 = alokasi(103); // Pegawai dengan ID 103
    
    cout << "   - Alokasi pegawai 101: " << (peg1 != Nil ? "Berhasil" : "Gagal") << endl;
    cout << "   - Alokasi pegawai 102: " << (peg2 != Nil ? "Berhasil" : "Gagal") << endl;
    cout << "   - Alokasi pegawai 103: " << (peg3 != Nil ? "Berhasil" : "Gagal") << endl;
    
    insertFirst(L_pegawai, peg1);
    insertLast(L_pegawai, peg2);
    insertLast(L_pegawai, peg3);
    
    cout << "   Data setelah insert: ";
    printInfo(L_pegawai);
    cout << "   Jumlah induk: " << nbList(L_pegawai) << endl;
    
    // ========== 3. Alokasi dan insert anak ==========
    cout << "\n3. Alokasi dan insert anak:" << endl;
    
    // Anak untuk pegawai 101
    address_anak anak1_101 = alokasiAnak(1);
    address_anak anak2_101 = alokasiAnak(2);
    address_anak anak3_101 = alokasiAnak(3);
    
    insertFirstAnak(peg1->lanak, anak1_101);
    insertLastAnak(peg1->lanak, anak2_101);
    insertLastAnak(peg1->lanak, anak3_101);
    
    cout << "   - Anak pegawai 101: ";
    printInfoAnak(peg1->lanak);
    
    // Anak untuk pegawai 102
    address_anak anak1_102 = alokasiAnak(4);
    insertFirstAnak(peg2->lanak, anak1_102);
    
    cout << "   - Anak pegawai 102: ";
    printInfoAnak(peg2->lanak);
    
    // ========== 4. Tampilkan semua data ==========
    cout << "\n4. Tampilkan semua data:" << endl;
    displayMultiList(L_pegawai);
    
    // ========== 5. Cari elemen ==========
    cout << "5. Pencarian elemen:" << endl;
    address foundPeg = findElm(L_pegawai, 102);
    cout << "   - Cari pegawai 102: " << (foundPeg != Nil ? "Ditemukan" : "Tidak ditemukan") << endl;
    
    address_anak foundAnak = findElm(peg1->lanak, 2);
    cout << "   - Cari anak 2 di pegawai 101: " << (foundAnak != Nil ? "Ditemukan" : "Tidak ditemukan") << endl;
    
    // ========== 6. Delete anak ==========
    cout << "\n6. Delete anak 2 dari pegawai 101:" << endl;
    cout << "   Sebelum: ";
    printInfoAnak(peg1->lanak);
    delPAnak(peg1->lanak, 2);
    cout << "   Sesudah: ";
    printInfoAnak(peg1->lanak);
    
    // ========== 7. Delete induk ==========
    cout << "\n7. Delete induk (pegawai) 102:" << endl;
    cout << "   Sebelum delete: ";
    printInfo(L_pegawai);
    delP(L_pegawai, 102);
    cout << "   Sesudah delete: ";
    printInfo(L_pegawai);
    
    // ========== 8. Tampilkan data setelah penghapusan ==========
    cout << "\n8. Data setelah penghapusan:" << endl;
    displayMultiList(L_pegawai);
    
    // ========== 9. Test insertAfter ==========
    cout << "\n9. Test insertAfter:" << endl;
    address peg4 = alokasi(104);
    address peg5 = alokasi(105);
    
    insertLast(L_pegawai, peg4);
    
    // Insert peg5 setelah peg1
    insertAfter(L_pegawai, peg5, peg1);
    cout << "   Setelah insert pegawai 105 setelah 101: ";
    printInfo(L_pegawai);
    
    // ========== 10. Test deleteFirst dan deleteLast ==========
    cout << "\n10. Test deleteFirst dan deleteLast:" << endl;
    address deletedPeg;
    
    delFirst(L_pegawai, deletedPeg);
    cout << "   - Delete first: ";
    printInfo(L_pegawai);
    
    delLast(L_pegawai, deletedPeg);
    cout << "   - Delete last: ";
    printInfo(L_pegawai);
    
    // ========== 11. Hapus semua data ==========
    cout << "\n11. Hapus semua data (delAll):" << endl;
    delAll(L_pegawai);
    cout << "   List kosong? " << (ListEmpty(L_pegawai) ? "Ya" : "Tidak") << endl;
    
    cout << "\n=== PROGRAM SELESAI ===" << endl;
    
    return 0;
}
```

> Output
> ![Screenshot bagian x](output/modul10no1.jpg)

Penjelasan :
kode diatas bertujuan mengimplementasikan struktur data Binary Search Tree (BST) dengan operasi dasar menyisipkan node dan mencetak isi tree menggunakan traversal in-order. BST dibangun dengan aturan bahwa node kiri lebih kecil dan node kanan lebih besar dari parent, menghasilkan urutan terurut menaik saat traversal in-order. Contoh data {1, 2, 6, 4, 5, 3, 6, 7} membentuk BST dengan struktur tertentu dan output "1 - 2 - 3 - 4 - 5 - 6 - 7 -".

### Soal 2
Buatlah ADT Multi Linked list sebagai berikut di dalam file “circularlist.h”:
```
Type infotype : mahasiswa <
Nama:string
Nim:string
Jenis_kelamin:char
Ipk:float>
Type address : pointer to ElmList
Type ElmList <
info : infotype
next :address>
Type List <
First : address>
```

```cpp
int main() {
cout << "Hello World" << endl;
address root = Nil;
insertNode(root,1);
insertNode(root,2);
insertNode(root,6);
insertNode(root,4);
insertNode(root,5);
insertNode(root,3);
insertNode(root,6);
insertNode(root,7);
InOrder(root);
cout<<"\n";
cout<<"kedalaman : "<<hitungKedalaman(root,0)<<endl;
cout<<"jumlah Node : "<<hitungNode(root)<<endl;
cout<<"total : "<<hitungTotal(root)<<endl;
return 0;
}
```

### file bstree.h
```cpp
#ifndef BSTREE_H
#define BSTREE_H

#define Nil NULL

typedef int infotype;

typedef struct Node *address;
struct Node {
    infotype info;
    address left;
    address right;
};

address alokasi(infotype x);
void insertNode(address &root, infotype x);
address findNode(address root, infotype x);
void printInorder(address root);

// Fungsi tambahan untuk latihan 2
int hitungJumlahNode(address root);
int hitungTotalInfo(address root);
int hitungKedalaman(address root);

#endif
```
### file bstree.cpp
```cpp
#include <iostream>
#include "bstree.h"
using namespace std;

address alokasi(infotype x) {
    address newNode = new Node;
    newNode->info = x;
    newNode->left = Nil;
    newNode->right = Nil;
    return newNode;
}

void insertNode(address &root, infotype x) {
    if (root == Nil) {
        root = alokasi(x);
    } else if (x < root->info) {
        insertNode(root->left, x);
    } else if (x > root->info) {
        insertNode(root->right, x);
    }
}

address findNode(address root, infotype x) {
    if (root == Nil || root->info == x) {
        return root;
    } else if (x < root->info) {
        return findNode(root->left, x);
    } else {
        return findNode(root->right, x);
    }
}

void printInorder(address root) {
    if (root != Nil) {
        printInorder(root->left);
        cout << root->info << " - ";
        printInorder(root->right);
    }
}

// Implementasi fungsi latihan 2
int hitungJumlahNode(address root) {
    if (root == Nil) return 0;
    return 1 + hitungJumlahNode(root->left) + hitungJumlahNode(root->right);
}

int hitungTotalInfo(address root) {
    if (root == Nil) return 0;
    return root->info + hitungTotalInfo(root->left) + hitungTotalInfo(root->right);
}

int hitungKedalaman(address root) {
    if (root == Nil) return 0;
    int leftDepth = hitungKedalaman(root->left);
    int rightDepth = hitungKedalaman(root->right);
    return (leftDepth > rightDepth ? leftDepth : rightDepth) + 1;
}
```
### file main.cpp
```cpp
#include <iostream>
#include "bstree.h"
using namespace std;

int main() {
    cout << "Hello World" << endl;
    address root = Nil;
    insertNode(root, 1);
    insertNode(root, 2);
    insertNode(root, 6);
    insertNode(root, 4);
    insertNode(root, 5);
    insertNode(root, 3);
    insertNode(root, 6); // duplikat
    insertNode(root, 7);
    
    cout << "Inorder traversal: ";
    printInorder(root);
    cout << endl;
    
    cout << "Kedalaman tree: " << hitungKedalaman(root) << endl;
    cout << "Jumlah node: " << hitungJumlahNode(root) << endl;
    cout << "Total nilai node: " << hitungTotalInfo(root) << endl;
    
    return 0;
}
```

> Output
> ![Screenshot bagian x](output/modul10no2.jpg)

Penjelasan :
kode diatas menambahkan fungsi utilitas untuk menganalisis properti BST, yaitu menghitung jumlah node, total nilai semua node, dan kedalaman tree. Ketiga fungsi ini diimplementasikan secara rekursif, di mana perhitungan kedalaman menggunakan prinsip mencari jalur terpanjang dari root ke leaf. Untuk BST dari latihan 1, diperoleh hasil 7 node, total nilai 28, dan kedalaman 5.


1. https://www.w3schools.com/cpp/cpp_for_loop_nested.asp
2. https://www.w3schools.com/cpp/cpp_arrays.asp
3. https://www.w3schools.com/cpp/cpp_arrays_loop.asp
4. https://www.w3schools.com/cpp/cpp_references.asp
5. https://www.w3schools.com/cpp/cpp_pointers.asp
6. https://www.w3schools.com/cpp/cpp_function_param.asp
7. https://www.w3schools.com/cpp/cpp_function_array.asp
8. https://www.w3schools.com/cpp/cpp_stacks.asp
